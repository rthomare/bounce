//  Created by Rohan Thomare on 12/23/24.

import UIKit
import Messages
import SwiftUI

func CreateAppController(onSongSelected: @escaping ((Song, SongSelectionType) -> Void)) -> AppController {
    return AppController(
        createController: CreateController(DefaultSongLinkRequestFactory.self, onSongSelected: onSongSelected),
        receiveController: ReceiveController(DefaultSongLinkRequestFactory.self))
}

class MessagesViewController: MSMessagesAppViewController {
    var _hostingController: UIHostingController<BounceApp>?
    var _appController: AppController?
    var _appView: BounceApp?
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        _appController = CreateAppController(onSongSelected: self._handleSongGeneration)
    }
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        _appController = CreateAppController(onSongSelected: self._handleSongGeneration)
    }
    
    override func loadView() {
        super.loadView()
        _appView = BounceApp(_appController!)
        _hostingController = UIHostingController(rootView: _appView!)
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        // Add the hosting controller as a child
        addChild(_hostingController!)
        _hostingController!.view.translatesAutoresizingMaskIntoConstraints = false
        view.addSubview(_hostingController!.view)

        // Set up constraints for the hosting controller's view
        NSLayoutConstraint.activate([
            _hostingController!.view.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            _hostingController!.view.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            _hostingController!.view.topAnchor.constraint(equalTo: view.topAnchor),
            _hostingController!.view.bottomAnchor.constraint(equalTo: view.bottomAnchor)
        ])

        _hostingController!.didMove(toParent: self)
    }
    
    // MARK: Private Functions
    
    private func _init() {
        _appController = CreateAppController(onSongSelected: self._handleSongGeneration)
    }
    
    private func _handleSongGeneration(_ song: Song, _ selectionType: SongSelectionType) {
        let message = MessageFactory.buildSongMessage(song)!
        
        // Send the message
        if (selectionType == .shake) {
            _appController?.handle(action: .recievingSong(song: song.abridged()))
            requestPresentationStyle(.expanded)
        } else {
            activeConversation?.send(message, completionHandler: { [weak self] error in
                guard let self else { return }
                self.requestPresentationStyle(.compact)
                if let error = error {
                    print("Failed to send message: \(error.localizedDescription)")
                } else {
                    print("Message sent successfully!")
                }
            })
            
        }
    }

    // MARK: - Conversation Handling
    
    override func willBecomeActive(with conversation: MSConversation) {
        // Called when the extension is about to move from the inactive to active state.
        // This will happen when the extension is about to present UI.
        
        // Use this method to configure the extension and restore previously stored state.
    }
    
    override func didBecomeActive(with conversation: MSConversation) {
        if let selectedMessage = conversation.selectedMessage, let song = MessageFactory.getSongFromMessage(selectedMessage) {
            _appController?.handle(action: .recievingSong(song: song))
            requestPresentationStyle(.expanded)
        } else {
            _appController?.handle(action: .startCreation)
            requestPresentationStyle(.compact)
        }
    }
    
    override func didResignActive(with conversation: MSConversation) {
        // Called when the extension is about to move from the active to inactive state.
        // This will happen when the user dismisses the extension, changes to a different
        // conversation or quits Messages.
        
        // Use this method to release shared resources, save user data, invalidate timers,
        // and store enough state information to restore your extension to its current state
        // in case it is terminated later.
        
        // no-op
    }
   
    override func didReceive(_ message: MSMessage, conversation: MSConversation) {
        // Called when a message arrives that was generated by another instance of this
        // extension on a remote device.
        
        // Use this method to trigger UI updates in response to the message.
        
        // TODO: prefetch the data for the songlink to simplify transitions
    }
    
    override func didStartSending(_ message: MSMessage, conversation: MSConversation) {
        // Called when the user taps the send button.
    }
    
    override func didCancelSending(_ message: MSMessage, conversation: MSConversation) {
        // Called when the user deletes the message without sending it.
    
        // Use this to clean up state related to the deleted message.
    }
    
    override func willTransition(to presentationStyle: MSMessagesAppPresentationStyle) {
        // Called before the extension transitions to a new presentation style.
    
        // Use this method to prepare for the change in presentation style.
    }
    
    override func didTransition(to presentationStyle: MSMessagesAppPresentationStyle) {
        // Called after the extension transitions to a new presentation style.
    
        // Use this method to finalize any behaviors associated with the change in presentation style.
    }

}
